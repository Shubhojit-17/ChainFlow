// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title MockVerifier
 * @author ChainFlow Factor Team
 * @notice Simulates a ZK-SNARK Groth16 Verifier for local Hardhat development
 * @dev This mock replaces the actual SnarkJS-generated verifier contract
 *      In production, this would be replaced with a verifier generated by:
 *      1. Compiling a Circom circuit (invoice_validity.circom)
 *      2. Running trusted setup (Powers of Tau ceremony)
 *      3. Generating the Solidity verifier via snarkjs
 * 
 *      The circuit would prove:
 *      - Invoice amount > 0
 *      - Buyer's Tax ID is in a valid Merkle tree
 *      - Without revealing the actual buyer identity
 */
contract MockVerifier {
    // ============ State Variables ============
    
    /// @notice Contract owner with admin privileges
    address public owner;
    
    /// @notice Whether the verifier should accept all proofs (for testing)
    bool public alwaysAccept;
    
    /// @notice Counter for total proofs verified
    uint256 public totalProofsVerified;
    
    /// @notice Mapping to track verified proof hashes (prevents replay)
    mapping(bytes32 => bool) public usedProofs;

    // ============ Events ============
    
    /// @notice Emitted when a proof verification is attempted
    /// @param proofHash The hash of the proof parameters
    /// @param publicInput The public input to the circuit
    /// @param verified Whether the proof was accepted
    event ProofVerified(bytes32 indexed proofHash, uint256 publicInput, bool verified);
    
    /// @notice Emitted when verifier mode is changed
    /// @param alwaysAccept The new mode setting
    event VerifierModeChanged(bool alwaysAccept);

    // ============ Modifiers ============
    
    modifier onlyOwner() {
        require(msg.sender == owner, "MockVerifier: caller is not the owner");
        _;
    }

    // ============ Constructor ============
    
    /// @notice Initializes the MockVerifier in accept-all mode
    constructor() {
        owner = msg.sender;
        alwaysAccept = true; // Default to accepting all proofs for demo
    }

    // ============ External Functions ============
    
    /**
     * @notice Verifies a Groth16 ZK-SNARK proof
     * @dev Signature matches the standard SnarkJS-generated verifier
     *      In a real implementation, this performs elliptic curve pairings
     *      to verify the proof against the verification key
     * 
     *      Proof components (in a real Groth16 proof):
     *      - a: First element of the proof (G1 point)
     *      - b: Second element of the proof (G2 point)
     *      - c: Third element of the proof (G1 point)
     *      - input: Public inputs to the circuit
     * 
     * @param a First proof element (2 uint256 representing G1 point)
     * @param b Second proof element (2x2 uint256 representing G2 point)
     * @param c Third proof element (2 uint256 representing G1 point)
     * @param input Public inputs array (hash of buyer ID + salt)
     * @return Whether the proof is valid
     */
    function verifyProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[1] calldata input
    ) external returns (bool) {
        // Calculate proof hash to prevent replay attacks
        bytes32 proofHash = keccak256(
            abi.encodePacked(a[0], a[1], b[0][0], b[0][1], b[1][0], b[1][1], c[0], c[1], input[0])
        );
        
        // Check for proof replay (optional security feature)
        // In demo mode, we skip this check
        // require(!usedProofs[proofHash], "MockVerifier: proof already used");
        
        bool verified = alwaysAccept;
        
        if (verified) {
            usedProofs[proofHash] = true;
            totalProofsVerified++;
        }
        
        emit ProofVerified(proofHash, input[0], verified);
        
        return verified;
    }
    
    /**
     * @notice View function to verify proof without state changes
     * @dev Useful for off-chain verification checks
     * @param a First proof element
     * @param b Second proof element
     * @param c Third proof element
     * @param input Public inputs array
     * @return Whether the proof would be valid
     */
    function verifyProofView(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[1] calldata input
    ) external view returns (bool) {
        // Suppress unused parameter warnings
        a; b; c; input;
        return alwaysAccept;
    }

    // ============ Admin Functions ============
    
    /**
     * @notice Sets whether the verifier accepts all proofs
     * @dev Only callable by owner - used for testing failure scenarios
     * @param _alwaysAccept Whether to accept all proofs
     */
    function setAlwaysAccept(bool _alwaysAccept) external onlyOwner {
        alwaysAccept = _alwaysAccept;
        emit VerifierModeChanged(_alwaysAccept);
    }
    
    /**
     * @notice Resets a used proof hash (for testing)
     * @param proofHash The proof hash to reset
     */
    function resetProofHash(bytes32 proofHash) external onlyOwner {
        usedProofs[proofHash] = false;
    }
    
    /**
     * @notice Transfers ownership of the contract
     * @param newOwner The address of the new owner
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "MockVerifier: new owner is zero address");
        owner = newOwner;
    }
}
